TCP и UDP

Каждый процесс приложения, запущенный на сервере, использует определенный номер порта (либо заданный по умолчанию, либо настроенный вручную системным администратором). Не допускается использование двумя различными службами на одном и том же сервере одного и того же порта с одинаковым протоколом транспортного уровня.

Например, приложение веб-сервера и приложение передачи файлов, которые запущены на одном узле, не могут быть настроены на использование одного и того же порта (например, TCP-порта 80). Активное серверное приложение, которому присвоен какой-либо определенный порт, считается открытым, что означает, что транспортный уровень может принимать и обрабатывать сегменты, направляемые на этот порт. Любой входящий запрос, который адресован правильному сокету, будет принят, а данные будут переданы приложению сервера. На сервере может быть одновременно открыто сразу несколько портов, по одному для каждого активного приложения сервера.

В некоторых странах при встрече двух человек принято обмениваться рукопожатиями. Рукопожатие рассматривается обеими сторонами как сигнал для дружеского приветствия. Подключения в сети осуществляются примерно так же. При подключениях по протоколу TCP клиент узла устанавливает связь с сервером.

в три этапа:

Этап 1. Инициирующий клиент запрашивает сеанс обмена данными «клиент-сервер» с сервером.

Этап 2. Сервер подтверждает сеанс обмена данными «клиент-сервер» и запрашивает сеанс обмена данными «сервер-клиент».

Этап 3. Инициирующий клиент подтверждает сеанс обмена данными «сервер-клиент».

Для прекращения соединения в заголовке сегмента должен быть установлен управляющий флаг Finish (FIN). Для завершения каждого одностороннего TCP-сеанса используется двухстороннее квитирование (рукопожатие), которое состоит из сегмента FIN и сегмента ACK (подтверждение). Следовательно, чтобы завершить один сеанс связи, поддерживаемый протоколом TCP, необходимы четыре операции обмена данными, которые завершат оба сеанса.

Примечание. В данной трактовке понятия «клиент» и «сервер» используются в качестве справки для облегчения понимания, но процесс завершения связи может быть инициирован любым из двух узлов с открытым сеансом.

Этап 1. Когда у клиента больше нет данных для отправки в потоке, он отправляет сегмент с установленным флагом FIN.

Этап 2. Сервер отправляет подтверждение ACK, чтобы подтвердить получение FIN для завершения сеанса связи «клиент-сервер».

Этап 3. Сервер отправляет клиенту сегмент FIN, чтобы завершить сеанс связи «сервер-клиент».

Этап 4. Клиент отправляет в ответ сегмент ACK для подтверждения получения сегмента FIN от сервера.

После подтверждения всех сегментов сеанс закрывается.

Узлы отслеживают каждый сегмент данных, передаваемых во время сеанса, и обмениваются информацией о полученных данных с использованием сведений в заголовке TCP. TCP — это полнодуплексный протокол, в котором каждое соединение представляет два односторонних потока обмена данными, или сеанса. Для установления связи узлы используют трехстороннее квитирование. Биты управления в заголовке TCP обозначают этап и состояние подключения.

Трехстороннее квитирование:

Сначала устанавливается, присутствует ли устройство назначения в сети.
Затем проверяется, имеется ли на устройстве назначения активный сервис и принимает ли он запросы на номер порта назначения, который инициирующий клиент планирует использовать.
Далее устройству назначения сообщается, что клиент источника планирует установить сеанс связи на этом номере порта.
По завершении обмена данными все сеансы закрываются, а соединение прерывается. Механизмы подключения и осуществления сеанса связи включают в себя функции TCP, обеспечивающие надежность.

Шесть битов в поле битов управления в заголовке сегмента TCP называются флагами. Каждый флаг представляет собой бит, который либо включен, либо выключен. Флаг RST используется для сброса соединения при возникновении ошибки или в случае превышения времени ожидания.

UDP — это простой протокол, обеспечивающий работу основных функций транспортного уровня. Он характеризуется существенно меньшими накладными расходами по сравнению с протоколом TCP. Он не использует установление соединения и не предлагает сложные механизмы повторной передачи данных, упорядочивания и управления потоком, которые обеспечивают надежность.

Это вовсе не означает, что приложения, которые используют UDP, всегда ненадежны или что UDP — неполноценный протокол. Это лишь означает, что функции обеспечения надежности не реализуются протоколом транспортного уровня и при необходимости должны быть реализованы на других уровнях.

Низкие накладные расходы, свойственные UDP, делают его просто незаменимым в случаях, когда требуется протокол, осуществляющий лишь транзакции по отправке запросов и получению ответов. Например, выбор в пользу протокола TCP для DHCP может обернуться ненужным увеличением объема сетевого трафика. При возникновении проблем с запросом или ответом устройство просто отправляет запрос повторно, если ответ на него не получен.

Как и в случае с сегментами TCP, когда на узел назначения отправляются датаграммы UDP, они могут использовать разные пути и прибыть в неправильном порядке. Протокол UDP не отслеживает порядковые номера, как это делает TCP. У UDP нет способа повторно скомпоновать датаграммы в том порядке, который использовался при их передаче.

Таким образом, протокол UDP просто повторно собирает данные в том порядке, в котором они были приняты, и пересылает их приложению. Если последовательность данных важна для работы приложения, оно должно определить правильную последовательность и выбрать оптимальный способ обработки данных.

Как и приложениям, использующим протокол TCP, серверным приложениям на основе протокола UDP присваиваются известные или зарегистрированные номера портов. Когда эти приложения или процессы запущены на сервере, они принимают данные, совпадающие с присвоенным номером порта. Если UDP получает датаграмму, адресованную одному из этих портов, он пересылает данные приложения соответствующему приложению исходя из его номера порта.

Как и в случае с TCP, обмен данными между клиентом и сервером инициируется клиентским приложением, которое запрашивает данные с серверного процесса. Процесс UDP-клиента динамически выбирает номер порта из диапазона номеров портов и использует его в качестве порта источника для сеанса связи. Как правило, порт назначения — это общеизвестный или зарегистрированный номер порта, присвоенный процессу сервера.

После того как клиент выбрал порты источника и назначения, эта же пара портов будет указана в заголовке всех датаграмм, которые используются в процессе пересылки. Чтобы сервер мог вернуть данные клиенту, номера портов источника и назначения в заголовке датаграммы указываются в обратном порядке.
